---
title: 'Techniques Quantitatives de Gestion : exploitation des données (3)'
author: Ludovic Vigneron
date: '2022-09-22'
categories:
  - Cours
  - R
  - TQG
  - Finance
tags:
  - Cours
  - Exercice
  - R
  - TQG
---

**Après le test de différence de moyennes, nous attaquons dans cette session à la régression linéaire simple. Celle-ci permet d'établir le degré d'association entre une variable expliquée ($y_i$) et une variable explicative ($x_i$). La relation mesurée est matérialisée par une équation linéaire à un facteur (celle d'une droite). On a ainsi : $y_i=\alpha+\beta.x_i$. Cette approche se distingue du simple coefficient de corrélation dans la mesure où elle implique notamment un sens à la relation. L'évolution de la variable explicative génère l'évolution de la variable expliquée.**

L'ensemble est établi au travers des moindres carrés ordinaires (MCO). R propose une fonction simple pour réaliser l'ajustement: **lm()**. Elle prend comme premier argument l'équation de régression (variable expliquée ~ variable explicative) et comme second (data) le nom de la data frame dans laquelles sont stockées les données (à défaut il faudra indiquer nom_data_frame$ pour le nom de chaque variable dans l'équation). Mais voyons tous ça au travers d'une série d'application.

# Tâche n°1 Mesurez au travers d'une regression linéaire simple le degré d'association entre le résultat au test et le ratio enseignés/enseignant

Il s'agit pour nous d'estimer un modèle linéaire sur les données des écoles californiennes pour obtenir approximation de la relation testscr str. Celle-ci prendra la forme:

$$testscr_i=\hat{\alpha}+\hat{\beta}.str_i+\epsilon_i$$

Commençons par charger les packages habituels. 

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(haven)
library(gt)
```

Puis, importons les données dans R. Si vous ne les avez pas encore dans votre dossier de travail, je vous renvoie aux deux postes précédents ([ici](https://myecontricks.netlify.app/post/2022-09-20-techniques-quantitatives-de-gestion-exploitation-des-donn-es-1/) et [là](https://myecontricks.netlify.app/post/2022-09-21-techniques-quantitatives-de-gestion-exploitation-des-donn-es-2/)).

```{r}
caschool <- read_dta("caschool.dta")
```

Limitons la base aux seules données utiles str et testscr.

```{r}
variables <- caschool %>% select(str,testscr)
```

Ceci fait avant d'estimer notre modèle traçons le nuage de points correspondant à l'intersection de nos deux variables. Pour cela, utilisons **ggplot()** une fonction *du tidyerse*. Indiquons la data frame dans laquelle les données sont stockées, les variables utilisées en abscisse et un ordonné. Ajoutons avec geom_point() que nous voulons un nuage de points (pour ceux qui voudraient en savoir plus sur ggplot vous trouverez [ici](https://myecontricks.netlify.app/categories/datavisualisation/) une série de posts portant sur son utilisation)

```{r}
ggplot(data=variables,aes(x=str,y=testscr))+
  geom_point()
```

La forme du nuage nous laisse penser qu'il y aurait une relation négative entre les variables. Il semble qu'en moyenne, plus str est important, moins testscr l'est. 

Réalisons le régression pour voir si on a bin un beta négatif.

```{r}
lm(testscr~str,data=variables)
```

C'est le cas. Voyons ce que cela donne graphiquement en ajoutant à notre précédent graphe une droite reprenant la valeur de paramètres estimées. Pour cela, utilisons le **geom_abline()**.

```{r}
ggplot(data=variables,aes(x=str,y=testscr))+
  geom_point()+
  geom_abline(intercept = 698.93,slope = -2.28, color='red')
```

Voyons si la relation mise au jour apparaît statistiquement significatif. Nous testerons l'hypothèse H0 que le coefficient beta égale à 0 contre H1 beta est différent de 0. Pour cela, le plus simple est d'utiliser la fonction **summary()** sur notre modèle de régression.

```{r}
lm(testscr~str,data=variables) %>% summary()
```

Nous obtenons toute une série de nouvelles informations notamment des tests statistiques sur les paramètres du modèle individuellement (les tests de Student) ou globalement (le test de Fisher sur le dernière ligne). Ici, l'ensemble rejet les hypothèses H0 associées. Si on prend le beta de str, on a pour le test (de Student H0 beta = 0) pratiqué produit une p-value trés trés petite (bien inférieur à 1% 0.01). Cela permet très largement de rejeter l'hypothèse H0. Le coefficient est bien statistiquement différent à 0.


Interprétons rapidement la relation mis en évidence. Tout d'abord, on peut dire si str tend vers 0 alors le score du test tend vers l'ordonnée à l'origine de la droite, le coefficient alpha (la constante du modèle), c'est à dire ici 698.93. Si str = 1, on a $698.93-2.27/times{1}=696.6$...  

On peut obtenir les prédictions du modèle pour différentes valeurs très facilement en utilisant la fonction **predict()**. Elle prend comme premier argument le modèle et comme second les valeurs de la variable explicatives pour lesquels vous voulez réaliser la prédiction (dans une data frame). Choisisons 0, 1 , 2 ainsi la moyenne de str et sa médiane. 

```{r}
lm(testscr~str,data=variables) %>% 
  predict(data.frame(str=c(0,1,2,19.64,19.72))) %>% 
  data.frame(str=c(0,1,2,19.64,19.72),prediction=.) %>%
  `rownames<-`( NULL )
```

# Tâche n°2: Estimez le Beta issu du modèle de marché pour les actions Microsoft, Apple et Facebook (Meta)

La première étape de ce travail consiste à obtenir les données de associé aux cours des actions et de l'indice de marché (ici le S&P500). Pour cela, nous allons utiliser le package *quantmod* qui propose toute une série de fonction dédiée à des applications de finance de marché.

```{r message=FALSE, warning=FALSE}
library(quantmod)
```

La fonction qui nous intéressera ici est **getSymbols()** qui permet d'obtenir les informations de cours désirées à partir d'un liste de ticker. Ces codes peuvent être retrouvé assez facilement à partir d'une recherche internet. On a ainsi pour Microsoft MSFT, pour Apple AAPL, pour Facebook Meta et pour l'indice S&P500 ^GSPC. Indiquons le site d'extraction yahoo finance ainsi que la période sur laquelle les données doivent courir.

```{r}
getSymbols(c('MSFT','AAPL','Meta','^GSPC'),src='yahoo',
           from="2016-01-01",to="2016-12-31")
```

L'extraction produit un objet par ticker. Les données sont présentées au format xts qui est spécifique aux séries temporelles. Pour la suite, il est plus simple de les réunir au sein d'une seule data frame classique. Pour chaque ticker, nous établissons une data frame avec une variable date reprenant ce qui était indiqué en nom de ligne dans le xts. Puis, nous fusionnons l'ensemble avec **left_join()** et suprimons de l'environnement de travail les objets inutils.

```{r}
t1<-MSFT %>% data.frame %>% data.frame(Date = rownames(.), .) %>% 
  mutate(date=as.Date(Date)) 
t2<-AAPL %>% data.frame %>% data.frame(Date = rownames(.), .) %>% 
  mutate(date=as.Date(Date))
t3<-GSPC %>% data.frame %>% data.frame(Date = rownames(.), .) %>% 
  mutate(date=as.Date(Date))
t4<-META %>% data.frame %>% data.frame(Date = rownames(.), .) %>% 
  mutate(date=as.Date(Date))
dat<-left_join(t1,t2) %>% left_join(.,t3) %>% left_join(.,t4)
rm(t1,t2,t3,t4,MSFT,AAPL,META,GSPC)
```

Limitons l'information aux seuls cours de clôture ajustés (ticker.adjusted).

```{r}
dat<-dat %>% select(Date,MSFT.Adjusted,AAPL.Adjusted,
                    META.Adjusted,GSPC.Adjusted)
```

Calculons les rendements journaliers (jours de cotation) simples correspondant aux différentes séries.

$$ rend=\frac{prix_t}{prix_{t-1}}-1$$

```{r}
dat<-dat %>% mutate(ret_MSFT=MSFT.Adjusted/lag(MSFT.Adjusted)-1,
                    ret_AAPL=AAPL.Adjusted/lag(AAPL.Adjusted)-1,
                    ret_META=META.Adjusted/lag(META.Adjusted)-1,
                    ret_GSPC=GSPC.Adjusted/lag(GSPC.Adjusted)-1)
```

Avant d'aller plus loin sauvegardons des données dans un fichier .csv. Pour cela, il nous suffit d'utiliser la fonction **write.table()**.

```{r}
write.table(dat,file="return_actions.csv",row.names = FALSE,sep=';')
```

A partir de là, on peut régresser le rendement de chaque titre sur le rendement du marché pour obtenir le Beta du modèle de marché. Pour cela, nous utilisons le fonction **lm()** et générons les statistiques de présentation du résultat grâce à la fonction **summary()** associée.

```{r}
reg1<-summary(lm(ret_MSFT~ret_GSPC,data=dat))
reg1
```

Le beta correspond au coefficient associé aux rendements du titre. Pour Microsoft, il est de 1,23 et il est statistiquement significative. Le titre amplifie les mouvements de marché.

```{r}
reg2<-summary(lm(ret_AAPL~ret_GSPC,data=dat))
reg2
```

Pour Apple, il est de 1,02 et il est statistiquement significative. Le titre suit simplement les mouvements de marché.

```{r}
reg3<-summary(lm(ret_META~ret_GSPC,data=dat))
reg3
```

Pour Facebook, il est de 1,09 et il est statistiquement significative. Le titre suit les mouvements de marché.

Réunissons le tout dans un tableau unique. Etablissons une data frame incluant les betas, les t stat associé et les p-values.

```{r}
tab<-data.frame(c('Microsoft','Apple','Facebook'),
                rbind(round(reg1$coefficients[2,c(1,3,4)],digits=4),
                      round(reg2$coefficients[2,c(1,3,4)],digits=4),
                      round(reg3$coefficients[2,c(1,3,4)],digits=4))) 
colnames(tab)<-c(' ','Beta','t stat', 'p value')
tab$`p value`<-format(tab$`p value`,nsmall = 4)
tab
```

Mettons le résultat  sous la forme d'un tableau (**gt()**) et mettons l'ensemble en page.

```{r}
tab_<-gt(tab) %>% 
  tab_header(title='Beta issu du modèle de marché',
             subtitle = "Estimé sur 2016 en référence à l'indice S&P500")
tab_
```

Importons le résultat dans Word via **gtsave()**.

```{r}
gtsave(tab_,'Betas_v1.docx')
```

