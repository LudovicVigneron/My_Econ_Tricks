---
title: 'Techniques Quantitatives de Gestion : exploitation des données (4)'
author: Ludovic Vigneron
date: '2022-09-25'
categories:
  - Cours
  - R
  - TQG
  - Finance
tags:
  - Cours
  - Exercice
  - R
  - TQG
---

**Dans ce nouveau post, nous allons continuer à travailler sur la régression. L'objectif est de considérer des tests alternatifs sur les coefficient et d'étendre les modèles de manière à intégrer plusieurs facteurs explicatifs. Cela nous permettra de comprendre les biais créés par l'omission de variables dans les analyses de régression.**

# Tâche n°1 Reprenez les données sur les actions, estimez le modèle de marché pour chacun d'eux, réalisez un interval de confiance à 95% sur le beta, testez sa valeur par rapport à 1.

Comme à chaque fois, nous allons commencer par charger les packages qui vont être utilisés. On y retrouve les habituels *tidyverse*, *haven*, *gt*, mais aussi *car*, un nouveau package qui inclue des fonctions permettant la réalisation de tests statistiques complémentaires aux régressions.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(haven)
library(gt)
library(car)
```

On peut alors importer les données concernant les rendements des actions et de l'indice de marché que nous avons créé dans le post précédent. Si nécessaire vous pouvez le télécharger [ici](return_actions.csv). 

```{r}
return_actions <- read_delim("return_actions.csv",delim = ";")
```

Ceux-ci fait. On peut ré-estimer le modèle de marché  pour chaque titre (régression du rendement de l'action sur l'indice de marché en utilisant la fonction **lm()**) et stocker l'information dans des objets dédiés (portant ici le noms des actions).

```{r}
Ms<-lm(ret_MSFT~ret_GSPC,data=return_actions)
Ap<-lm(ret_AAPL~ret_GSPC,data=return_actions)
Fb<-lm(ret_META~ret_GSPC,data=return_actions)
```

Pour obtenir l'interval de confiance au niveau désiré (95%), il suffit de mobiliser la fonction **confint()**. Elle prend comme premier argument le modèle de régession et comme second (level) le niveau de confiance retenu. Produisons-la pour Microsoft (Ms).

```{r}
confint(Ms,level=0.95) 
```

On peut lire que le Beta de Microsoft à 95% de chance de se trouver entre 1.083 et 1.390. Néanmoins, l'ensemble reste peut lisible du fait de l'inclusion de l'intervalle de confiance de la constante et du nombre de chiffres après la virgule affiché. Réduisons tout cela. 

```{r}
confint(Ms,parm=2,level=0.95) %>% round(digits = 4)
```

Créons un tableau incluant l'ensemble des intervalles de confiance des beta des titre.

```{r}
tb<-rbind(confint(Ms,parm=2,level=0.95),
          confint(Ap,parm=2,level=0.95),
          confint(Fb,parm=2,level=0.95)) %>% round(digits=4)
rownames(tb)<-NULL
tb
```

Incluons-les dans le tableau des beta tel que nous l'avions réalisé dans le post précédent.

```{r}
reg1<-summary(Ms)
reg2<-summary(Ap)
reg3<-summary(Fb)
tab<-data.frame(c('Microsoft','Apple','Facebook'),
                rbind(round(reg1$coefficients[2,c(1,3,4)],digits=4),
                      round(reg2$coefficients[2,c(1,3,4)],digits=4),
                      round(reg3$coefficients[2,c(1,3,4)],digits=4)),
                tb) 
colnames(tab)<-c(' ','Beta','t stat', 'p value','2,5%','97,5%')
tab$`p value`<-format(tab$`p value`,nsmall = 4)
tab
```

Ajoutons un titre, un sous-titre ainsi qu'un chapeau sur les colonnes correspondant à l'intervalle de confiance.

```{r}
tab_<-gt(tab) %>% 
  tab_header(title='Beta issu du modèle de marché',
             subtitle = "Estimé sur 2016 en référence à l'indice S&P500") %>% 
  tab_spanner('Interval de confiance à 95%',columns = c('2,5%','97,5%'))
tab_
```

Transférons le résultat dans un document Word.

```{r}
gtsave(tab_,'Betas_conf_v1.docx')
```

Il nous reste à réaliser les test des beta contre la valeur 1. Les tests dans les modèles de régression sont réalisés contre 0. Pour cela, on peut utiliser la fonction **linearHypothesis()** du package *car*. Elle permet de mettre en oeuvre un test de restriction spécification de Fisher. Ses arguments sont le modèle de régression et la restriction (ici ret_GSPC=1).  

```{r}
linearHypothesis(Ms, "ret_GSPC = 1")
```

Pratiqué pour Microsoft, on rejette l'hypothèse H1 d'égalité du coefficient à 1 (que le modèle restreint est meilleur que le modèle de base). Appliquons la même procédure qui a un beta plus proche de 1. 

```{r}
linearHypothesis(Ap, "ret_GSPC = 1")
```

Cette fois ci, on ne peut rejeté H0. Le beta de Apple n'est pas statistiquement différent de 1.

La procédure rempli ses objectifs. Néanmoins, on pourrait préférer utiliser un test de Student comme pour l'hypothèse classique de beta égale 0 que l'on retrouve dans les résumés des modèles de régression. Pour cela, le plus simple (pour moi) est de créer soit même sa fonction de test. Rappelons la forme de statistique de Sudent:

$$Beta=\frac{\hat{\beta}-1}{\sigma/\sqrt{n}}$$
où 

$$\text{Standard error}=\sigma/\sqrt{n}$$

La fonction **pt()** permet de calculer la fonction de densité cumulative (la fonction de répartition) de la loi de Student. Mobilisons-la pour calculer la p value du test.

```{r}
ttest <- function(reg, coefnum, val){
  co <- coef(summary(reg))
  tstat <- (co[coefnum,1]-val)/co[coefnum,2]
  pval<- 2 * pt(abs(tstat), reg$df.residual, lower.tail = FALSE)
  ret<-round(c(tstat,pval),digits=4)
  names(ret)<-c('tstat','pval')
  return(ret)}
```

Appliquons notre fonction à la régression sur Microsoft (Ms) d'abord en testant beta égal à 0 pour comparer le résultat avec celui obtenu avec la fonction **summary()**, puis en testant beta égal à 1.

```{r}
ttest(Ms,2,0)
ttest(Ms,2,1)
```

Notre fonction maison produit bien le résultat attendu. Appliquons-la à toute nos actions. Agrégeons l'ensemble pour l'ajouter à notre tableau des beta.

```{r}
tc<-rbind(ttest(Ms,2,1),ttest(Ap,2,1),ttest(Fb,2,1))
tc
```

Créons la data frame correspondant.

```{r}
tab<-data.frame(tab,tc) 
colnames(tab)<-c(' ','Beta','t stat', 'p value','2,5%','97,5%',
                 't_stat', 'p_value')
tab
```

Mettons l'ensemble en page.

```{r}
tab_<-gt(tab) %>% 
  tab_header(title='Beta issu du modèle de marché',
             subtitle = "Estimé sur 2016 en référence à l'indice S&P500") %>% 
  tab_spanner('Beta=0',columns = c('t stat','p value')) %>% 
  tab_spanner('Interval de confiance à 95%',columns = c('2,5%','97,5%')) %>% 
  tab_spanner('Beta=1',columns = c('t_stat','p_value')) 
tab_
```

Transférons le tableau produit dans Word.

```{r}
gtsave(tab_,'Betas_conf_0_1_v1.docx')
```

# Tâche n°2 Revenez sur les cas des écoles californiennes, incluez dans la régresion les variables d'éléves apprenant l'anglais (el_pct), étudiez les liens entre les variables 

Commençons par recharger les données associés aux écoles (le fichier caschool). Si vous ne les avez pas encore vous pouvez les trouver en lien [ici](caschool.dta).

```{r}
caschool <- read_dta("caschool.dta")
```

Une fois les données importées, créons deux modèles de régression le premier expliquant testscr uniquement avec str (reg1) et le secons l'expliquant à la fois par str et el_pct.

```{r}
reg1<-lm(testscr~str,data=caschool)
reg2<-lm(testscr~str+el_pct,data=caschool)
```

Inspectons le résultat de la première régression via **summary()**.

```{r}
summary(reg1)
```

Le coefficient associé à str est de -2.2798 et il est statistiquement différent de zéro. Voyons ce qu'il en est dans le second modèle.

```{r}
summary(reg2)
```

La valeur du coefficient de str a changé. Elle est passée à -1.1013 mais est toujours statistiquement significatif. Le coefficient de el_pct est de -0.6497 et est statistiquement significatif.

Pour bien comprendre comment l'inclusion d'el_pct permet d'ajuster l'effet de str sur testscr, régressons str par el_pct. Cela nous indique l'effet de el_pct sur str. Sortons les résidus de la régression autrement dit la part de str non expliquée par el_pct.

```{r}
rega<-lm(str~el_pct,data=caschool)
res_a<-rega$residuals
head(res_a)
```

Régressons de la même manière testscr par el_pct et sortons le résidus, la part de testscr non expliqué par el_pct.

```{r}
regb<-lm(testscr~el_pct,data=caschool)
res_b<-regb$residuals
head(res_b)
```

Régressons ce dernier résidu par le premier en omettant la constante. Cela se fait en ajoutant -1 aux variables explicatives. 

```{r}
lm(res_b~res_a-1)
```

On retrouve retrouve le même coefficient que dans notre modèle incluant les deux variables pour expliquer testscr. L'inclusion de la seconde variable permet bien de corriger l'effet de str sur testscr de la partie de cet effet qui passe par el_pct. 



