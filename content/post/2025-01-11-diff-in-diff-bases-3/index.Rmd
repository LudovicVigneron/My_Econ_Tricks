---
title: diff in diff - bases 3
author: Ludovic Vigneron
date: '2025-01-11'
slug: []
categories:
  - DID
  - Inf_causale
  - R
tags:
  - DiD
  - Inf_causale
  - R
bibliography: references.bib
---

**Pour cette troisième note “rapide” sur la méthode *Difference-in-Difference*, nous allons considérer deux exemples tirés du cours d’introduction aux méthodes causales proposé par A. Colin Cameron de l’université de Californie-Davis (que vous trouverez [ici](https://cameron.econ.ucdavis.edu/causal/)). Ils sont initialement développés à partir de Stata. Nous nous efforcerons à la fois de les reproduire sous R et d’approfondir différents concepts. Mais avant d’aller plus loin, comme à chaque fois, chargeons les packages que nous allons utiliser: le *tidyverse*, que l’on ne présente plus, et *haven*, qui permet de lire et écrire des fichiers notamment au format .dta (le format de Stata), *labbeled*, qui permet de travailler plus facilement les données à étiquette (comme celles issues de Stata), fixest, qui permet l'estimation de modèles à effets fixes, *lmtest* et *sandwich*, qui permettent de réaliser des tests spécifiques sur les coefficients de régression, et car, qui proposent des tests complémentaires.**

```{r message=FALSE,warning=FALSE}

# packages de gestion des données
library(tidyverse)
library(haven)
library(labelled)

# packages de regression et tests
library(fixest)
library(lmtest)
library(sandwich)
library(car)
```

# **2x2 *Difference in Difference***

Ceci fait, abordons la première partie. L’ensemble est tiré de @tanaka2014. Dans ce papier, l’auteur se pose la question de savoir si un meilleur accès aux soins améliore la santé. Plus précisément si la gratuité des soins à un impacte positif sur le statut nutritionnel des enfants pauvres. Pour ce faire, il prend la cas de l’Afrique du sud post-Apartheid. Cela lui permet d’exploiter une variation exogène de la tarification des services de santé, le passage à la gratuité. et des différences marquées concernant l’implantation des cliniques sur le territoire héritées du régime discriminatoire qui régnait dans le pays avant 1991. En 1994, le gouvernement rend gratuit les services de santé pour les enfants de moins de 6 ans. Il s’agira ici de la date de traitement. Le changement tarifaire augmente en principe l’accès aux soins. Néanmoins, pour que cela soit effectif, il faut que les ménages pauvres résident dans une région avec une clinique (aient un accès possible aux soins). Les enfants des ménages situés dans de telles régions sont le groupe traité. Les enfants des ménages est situés dans une région sans clinique, où la gratuité ne sert à rien puisque l’accès matériel aux soins reste très difficile, sont le groupe de contrôle.

## **Chargement et exploration des données**

Chargeons les données de l'étude. Celles-ci sont disponibles [ici](https://cameron.econ.ucdavis.edu/causal/AED_HEALTHACCESS.DTA). Le fichier est un .dta. Utilisons la fonction read correspondant dans le package *haven*.

```{r}

dat<-read_dta("AED_HEALTHACCESS.dta")
```

Voyons ce que l’on a. Commençons dénombrer les variables et les observations.

```{r}

data.frame(nb_obs=nrow(dat),nb_var=length(dat))
```

La base obtenue comprend 1071 observations pour 26 variables, mais qu’elles sont-elles? Un des avantages des bases de données issues de logiciels comme Stata est qu’ils attachent différents attributs aux objets qu’ils traitent. Parmi eux, on trouve notamment des labels contenant de courts textes descriptifs des variables (ce qui peut être utile).

Pour obtenir, la liste des attributs d’un objet. Il suffit d’utiliser le fonction **attributes()**. Utilisons la sur dat notre base de données.

```{r}

dat %>% attributes()
```

On retrouve énormément d’éléments allant de la nature de l’objet aux noms des différentes variables qui le compose en passant par l’indexation des observations. Toutes ces informations ne sont pas nécessairement intéressantes... On peut les appeler une à une en les ciblant à l’aide de la fonction **attr()** en précisant l’élément via l’option which. Isolons le label de la base.

```{r}

dat %>% attr(which='label')
```

Ces commandes peuvent être utilisées sur chaque variable. Passons en revue les attributs de la variable waz.

```{r}

attributes(dat$waz)
```

La commande peut être utilisée pour modifier l’attribut ou même en créer un. Traduisons le label de waz et ajoutons cette traduction à la variable comme attribut trad.

```{r}

attributes(dat$waz)$trad<-"z Score pondéré par l'âge"
attributes(dat$waz)
```

Je ne saurais que vous conseiller de systématiquement ajouter ce type d’attributs à vos variables de manière à documenter votre travail particulièrement lorsque celui a vocation à être partagé.

On peut à partir de la fonction **att()** et de la commande d’itération **sapply()** répliquer la fonction **describe** de Stata.

```{r}

data.frame(Type_stockage=sapply(dat,typeof),
           Format=sapply(dat,attr,which='format.stata'),
           Label=sapply(dat,attr,which='label'))
```

Le même type de résultat (en moins ergonomique) peut être obtenu via **str()**.

```{r}

dat %>% str()
```

Le package *labelled* a été créé spécifiquement pour travailler les bases dans lesquelles les variables présentes des attributs. Sa fonction **look_for()** permet d’obtenir un tableau proche de celui présenté par **describe** dans Stata. Je ne saurai que recommander son utilisation.

```{r}

dat %>% look_for()
```

Ceci étant posé. Continuons notre exploration de la base. Les différents relevés sont réalisés sur des zones administratives (community) qui sont ou non équipées en clinique. Si elles le sont, elle permet d’identifier le groupe des traités. Si elles ne le sont pas, elle permet d’identifier le groupe de contrôle. Dénombrons ces différents types de zone.

```{r}

data.frame(nb_communauté=length(unique(dat$idcommunity)),
           com_traitée=length(unique(dat$idcommunity[which(dat$hightreat==1)])),
           com_controle=length(unique(dat$idcommunity[which(dat$hightreat==0)])))
```

Les mesures sont faites sur 54 communautés dont 26 disposent de cliniques et 28 n’en disposent pas. Voyons ce qu’il en est des observations pour chaque communauté. Ce faisant, identifions les observations pré et post traitement (le passage à la gratuité en 94).

```{r}

dat %>% group_by(idcommunity) %>% 
  summarise(nb_obs=n(),
            statut=ifelse(sum(hightreat)==nb_obs,"traité","control"),
            obs_pre=nb_obs-sum(post),
            obs_post=sum(post))
```

On remarque que le nombre d’observations est différent d’une communauté à l’autre et que ce nombre diffère également entre la période pré et la période post traitement. Nous n’avons donc pas ici un panel cylindré, autrement-dit des individus suivis sur l’ensemble de la durée de l’étude. Cela ne semble pas dû à une disparition des individus sur la période post traitement dans la mesure où pour certaine communauté le nombre d’observations est supérieure après le traitement.

Voyons ce qu’il en est globalement. Comptons le nombre d’observations du groupe des traités et du groupe de contrôle, toujours en distinguant les périodes avant et après traitement.

```{r}

dat %>% 
  mutate(traite=ifelse(dat$hightreat==1,'traité','controle')) %>% 
  select(traite,post) %>% 
  group_by(traite) %>%
  summarise(n=n(),av=n-sum(post),ap=sum(post),
            ev=ap-av)
```

Il y a, quelque soit le groupe (traités ou contrôles), une diminution du nombre d’observations avec le temps.

On peut par ailleurs noter que les mesures avant/après ne sont prises qu’à deux dates: 1993, juste avant la réforme, et 1998, 4 ans après. Au delà de cette date la différence entre l’équipement en cliniques des communautés est devenue petite. L’équipement est alors bien plus homogène. Les différences ne permettraient surement plus d'établir du distinction nette.

```{r}

dat %>% 
  mutate(traite=ifelse(dat$hightreat==1,'traité','controle')) %>% 
  select(traite,year) %>% 
  summarise(n=n(),.by=c(traite,year))
```

Pour avoir une vision encore plus claire de la structure de données, prenons le cas d’une communauté en particulier et examinons-la en détail. Prenons la numéro 59.

```{r}

dat %>% filter(idcommunity==59)
```

Plusieurs ménages ont plus d’une entrée dans l’extrait. Le ménage 590100 a deux entrées, le ménage 590090 en a trois. Jetons un oeil au premier.

```{r}

dat %>% filter(idcommunity==59 & hhid93==590100)
```

Les deux mesures sont réalisées sur l’échantillon des traités (hightreat égale à 1: là où il y a des cliniques en 1993). Il y en a une réalisée pré traitement et une post traitement. La mesure de 93 est faite sur une fille de moins d’un 1 an et la seconde en 98 sur un garçon de 3 ans.

On est loin d’avoir un panel. La spécification en *two ways fixed effect* (TWFE) n’est donc pas envisageable. nous resterons donc sur la spécification classique (*2x2 Diff in Diff*).

Maintenant que nous avons une vision plus claire de la structure de la base. Passons à l’analyse des variables. Revenons pour cela sur la définition de la variable expliquée waz. Il s’agit d’un Z-score autrement-dit le nombre d’écart-types qui sépare la valeur observée de la moyenne sur le groupe étudié. Ici, la mesure porte sur le poids des enfants. Le groupe étudié est défini par l’age de l’enfant. Ainsi, par exemple, une valeur de waz de -1 correspond à un enfant qui présenterait un poids inférieur de 1 écart-type à la moyenne des enfants de son âge. Plus cette mesure est négative, plus on est face à des enfants en mauvaise santé. Si le traitement, la gratuité des soins, est efficace après sa mise en oeuvre, on devrait constater une augmentation de la variable plus importante sur le groupe des traités que celle constatée sur le groupe de contrôle. Autrement-dit, on attend une *Diff in Diff* positive.

Pour commencer, limitons notre analyse à une *Diff in Diff* simple sans variables de contrôles. Ne gardons que waz, hightreat, post, postXhigh et idcommunity.

```{r}

dat_red_1<- dat %>% select(waz,hightreat,post,postXhigh,idcommunity)
```

Présentons quelques statistiques descriptives sur le modèle ce que propose Stata par défaut avec sa fonction **summarize**.

```{r}

dat_red_1 %>% 
  select(-idcommunity) %>% 
  summarize_all(
    .fun=list(~length(.),~mean(.),~sd(.),~min(.),~max(.))) %>% 
  unlist %>% matrix(nrow = 4, ncol=5) %>% as.data.frame() %>% 
  cbind(Variables=names(dat_red_1)[1:4],.) %>% 
  rename(Obs=V1,Mean=V2,Std.dev.=V3,Min=V4,Max=V5)
```

waz est la seule variable continue du lot. On peut noter qu’elle est en moyenne négative. Les enfants objets de l’étude sont les enfants de famille pauvres. Ils présentent pour leur age un poids inférieur à la moyenne (des enfants du même age dans la population générale). Les autres variables sont catégorielles binaires. Leur moyenne correspond à des proportions. On a ainsi 42,7% des observations qui sont faîtes sur le groupe traité, 46,6% qui sont réalisées après 1994 (en 1998) et 19,7% des observations qui sont faîtes sur les traités après 94.

## **Analyses 2x2 Diff in Diff**

Passons donc à l’analyse. Commençons par établir la matrice 2x2 des moyennes (contrôle/traité, avant/après).

```{r}

moy_av_t<-dat_red_1 %>% filter(post==0&hightreat==0) %>%
  summarise(av_t=mean(waz))
moy_ap_t<-dat_red_1 %>% filter(post==1&hightreat==0) %>%
  summarise(ap_t=mean(waz))
moy_av_nt<-dat_red_1 %>% filter(post==0&hightreat==1) %>%
  summarise(av_nt=mean(waz))
moy_ap_nt<-dat_red_1 %>% filter(post==1&hightreat==1) %>%
  summarise(ap_nt=mean(waz))
mat<-c(moy_av_t,moy_ap_t,moy_av_nt,moy_ap_nt) %>% unlist() %>% 
  matrix(ncol=2,nrow=2,byrow=FALSE)
rownames(mat)<-c("avant","apres")
colnames(mat)<-c("control","traite")
rm(moy_av_t,moy_ap_t,moy_av_nt,moy_ap_nt)
mat
```

A partir de là, il est facile de calculer notre *Diff in Diff*. Il suffit de soustraire à l’évolution avant/après mesurée sur les traités l’évolution avant/après mesurée sur le groupe de contrôle.

```{r}

(mat[2,2]-mat[1,2])-(mat[2,1]-mat[1,1])
rm(mat)
```

On a une augmentation moyenne de 0,52 points supérieurs de waz pour le groupe des traités (ceux qui avez une cliniques dans la communauté en 1993) par rapport au groupe de contrôle.

Le même résultat peut être obtenu à partir de la syntaxe *dplyr*.

```{r message=false}

moy<-dat_red_1 %>% 
  group_by(hightreat,post) %>% 
  summarise(moyenne=mean(waz),.groups='keep')
moy
moy<-moy%>% 
  pull(moyenne)
(moy[4]-moy[2])-(moy[3]-moy[1])
```

Le passage à la gratuité semble bien permettre d’améliorer la santé des enfants pauvres pour qui les barrières non tarifaires ne sont pas un problème (ceux ayant accès à une clinique). Mais pour conclure, il nous faut un test statistique sur cette *Diff in Diff*. Pour l’obtenir, procédons à la régression habituelle. Concernant les tests sur les coefficients, nous optons pour un *clustering* sur la communauté. On postule donc qu’il y a plus de variance entre communautés qu’à l’intérieure des communautés.

```{r}

reg<-lm(waz~hightreat+post+postXhigh,data=dat_red_1)
coeftest(reg,vcov. = vcovCL(reg,cluster=dat_red_1$idcommunity))
```

Le test confirme bien le résultat.

On peut reconstituer la matrice des moyennes à partir des différents coefficients de la régression DID.

La constante correspond au waz moyen sur le groupe de contrôle avant la date du traitement (traite==0 , post==0 et donc traite::post==0). Pour obtenir, la moyenne sur le groupe de contrôle après la date du traitement (traite==0 , post==1 et donc traite::post==0), on additionne simplement la constante et le coefficient associé à post. Pour le groupe des traités avant le traitement (traite==1, post==0 et donc traite::post==0), on additionne simplement la constante et le coefficient associé à traite. Pour les traités post traitement (traite==1, post==1 et donc traite::post==1), il suffit de tout additionner constante compris.

```{r}

cont_av<-coef(reg)[1] %>% sum()
cont_ap<-coef(reg)[c(1,3)] %>% sum()
trait_av<-coef(reg)[c(1,2)] %>% sum()
trait_ap<-coef(reg) %>% sum()
mat<-matrix(c(cont_av,cont_ap,trait_av,trait_ap),ncol=2)
colnames(mat)<-c('Controle','Traite')
rownames(mat)<-c('avant','aprés')
mat
```

La *Diff in Diff* évaluée est en quelque sorte brute (simple) dans la mesure où il n’y a pas de variables de contrôle. On peut sans difficulté en ajouter (mais cela peut poser un problème de *bad controls* dans certaines circonstances dont nous discuterons dans un prochain post). Faisons-le introduisons un effet fixe communauté, l’éducation de parent (homme et femme), la taille du ménage, le revue, le nombre de campagne de vaccinations sur la période, le nombre de clinique dans la communauté et si l’enfant est un garçon ou une fille. Sortons uniquement le coefficient donnant la *Diff in Diff*.

```{r}

reg_<-lm(waz~hightreat+post+postXhigh+
           factor(idcommunity)+fedu+medu+hhsizep+lntotminc+immuniz+nonclinic,
         data=dat)
coeftest(reg_)[4,]
```

Ici, il n’est pas possible de reconstituer la matrice des moyennes dans la mesure où la constante est ajustée en fonction de l’ensemble des variables catégorielles de la régression (notamment ici les effets fixes communauté et le sexe de l’enfant…).

Ici, il est impossible de procéder à un quelconque test de *parallel trend* ou même un test *placebo* faute de granularité dans les données. Nous terminerons donc ce premier exemple avec un graphe. Pour cela, préparons les données mobilisées.

```{r}
bas_g<-data.frame(traite=c("Controle","Controle","Traite","Traite"),
                  post=c("1993","1998","1993","1998"),
                  waz=c(mat[1,1],mat[2,1],
                        mat[1,2],mat[2,2]))
did<-coef(reg_)[4]
bas_g
```

Puis, établissons notre graphe.

```{r}
ggplot(bas_g, aes(x = post, 
                  y = waz, 
                  color = traite)) + 
  geom_point() +
  geom_line(aes(group = traite)) +
  labs(title="Effet du passage à la gratuité sur la santé des enfants pauvres", 
       y="Z-score  du poids moyen pondéré par classes d'âge",
       color="")+
  annotate(geom = "segment", x = "1993",
           xend = "1998",
           y = bas_g$waz[3],
           yend = bas_g$waz[4] - did,
           linetype = "dashed", color = "grey50") +
  annotate(geom = "segment", x = "1998",
           xend = "1998",
           y = bas_g$waz[4] , 
           yend = bas_g$waz[4] - did,
           linetype = "dotted", color = "blue") +
  annotate(geom = "label", x = "1998",
           y = bas_g$waz[4] - (did / 2), 
           label = "effet du programme", size = 3)+
  theme_bw()+
  theme(
    plot.title = element_text(hjust=0.5),
    axis.title.x = element_blank(),
    legend.position = "top"
  )
rm(list = ls(all.names = TRUE))
```

Notez qu'ici la ligne pointillé n'est pas parallèle à la rouge comme ce devrait être le cas dans une *Diff in Diff* classique. Cela est dû à l'ajustement via les variables de contrôle.

# ***Difference in Difference*** **avec périodes multiples**

Pour le second exemple développé, nous changeons de configuration avec cette fois plus de deux périodes de mesures (avant et après le traitement) et pour cela nous utiliserons une des bases de données mobilisées dans le manuel de Stata pour illustrer l’usage de sa fonction *didregress*. Dans cet application, on a un fournisseur de soins de santé qui gère des hôpitaux qui s’interroge sur l’impact de l’automatisation des procédures d’admission sur la satisfaction des patients. On a des données mensuelles sur les patients entre janvier et juillet. La procédure a été mise en place en avril dans une partie de ces hôpitaux.

## **Chargement et exploration des données**

Les données sont à charger à partir de l'url associée au manuel de Stata 17. Pour cela, il suffit d'introduire l'adresse comme argument dans la fonction **read_dta()**.

```{r}

dat2<-read_dta("https://www.stata-press.com/data/r17/hospdd.dta")
```

Ceci étant fait, voyons ce que contient la base. Comptons le nombre d'observations et le nombre de variables.

```{r}

data.frame(nb_obs=nrow(dat2),nb_var=length(dat2))
```

On a 7 368 observations et 5 variables. Mais que représentent ces variables? Utilisons notre réplication de **describe** pour accéder aux labels des variables.

```{r}
data.frame(Type_stockage=sapply(dat2,typeof),
           Format=sapply(dat2,attr,which='format.stata'),
           Label=sapply(dat2,attr,which='label'))
```

Les commentaires laissés ne sont pas très parlant. Revenons aux commandes R classiques avec **str()**.

```{r}

str(dat2)
```

Les choses sont plus claires. hospital est l’identifiant des hôptiaux. frequency est un indicateur de la fréquentation des hôpitaux par le patient avec 5 valeurs (1 Low … 5 Very hight). month est le mois de la visite. Il va de 1 pour janvier à 7 pour juillet. procedure, qui est notre variable d’intérêt, prend la valeur 1 à la fois s’il l’hôpital est traité (s'il a automatisé sa procédure d’admission à partir d’avril) et si l’observation est effectuée en avril ou après (après la mise en place du traitement). satis est notre variable expliquée. Il s’agit d’une moyenne de différentes notes qui vont de 0 (pas satisfait du tout) à 10 (très très satisfait) attribuées par les patients sur quatre critères concernant l’admission.

**look_for()** permet d’obtenir quelque chose d’un peu mieux.

```{r}

dat2 %>% look_for()
```

Voyons ce que donne ces variables. Regardons les premières observations.

```{r}

dat2 %>% head()
```

On peut noter que l’on a pour un même hôpital et un même mois plusieurs observations. Simplement il y a plusieurs patients admis par mois. Rein d’étonnant. Mais examinons cela de plus prés. Combien y a t-il d’hôpitaux ?

```{r}

length(unique(dat2$hospital))
```

On a 46 hôpitaux. Combien y a-t-il d’observations par hôpital?

```{r}

dat2 %>% count(hospital) %>% summarise(moy=mean(n))
```

On a en moyenne 160 observations par hôpital. Combien y a t-il d’observations par mois pour chaque hôpital?

```{r}

dat2 %>% group_by(hospital,month) %>% count() 
```

On peut noter qu’il y a toujours plus d’observations sur le mois de janvier (1) que sur les autres et cela sur tous les hôpitaux.

Ok, disons que l’on a une vision générale de la structure des données. Intéressons-nous à la répartition du traitement. Voyons combien on a d’hôpitaux traités et combien constituent le groupe de contrôle.

```{r}

cont<-dat2 %>%
  group_by(hospital) %>%
  summarise(b=ifelse(sum(procedure)==0,"Controles","Traités")) 
table(cont$b)
rm(cont)
```

Ce dénombrement apparaît dans la première partie de la sortie proposée par la fonction *didregress* de Stata. La seconde partie donne une information sur la première fois où on observe les groupes dans la base (comme non traité et comme traité). Répliquons-la.

```{r}

ent<-dat2 %>%
  group_by(hospital) %>%
  mutate(b=ifelse(sum(procedure)==0,"Controles","Traités"),
         m=month) %>% 
  group_by(hospital,b,procedure) %>% 
  summarise(min_=min(month), .groups = 'keep') 
cbind(Controle=
        c(minimum=min(ent$min_[which(ent$procedure==0&ent$b=="Controles")]),
          maximum=max(ent$min_[which(ent$procedure==0&ent$b=="Controles")])),
       Traite=
        c(minimum=min(ent$min_[which(ent$procedure==1&ent$b=="Traités")]),
          maximum=max(ent$min_[which(ent$procedure==1&ent$b=="Traités")])))
```

Ici, on a une base homogène. Toutes les observations du groupe de contrôle entrent dans la base dés le mois de janvier et le traitement est appliqué pour tous les traités en avril. On est sur une *Diff in Diff* classique pas une *staggered*.

Avant de la mettre en oeuvre, jetons un œil sur la distribution de la variable expliquée. Utilisons pour cela un histogramme rapidement fait.

```{r}

ggplot(data=dat2,aes(x=satis))+
  geom_histogram(color='black',bins=30)+
  geom_vline(xintercept = mean(dat2$satis),color='red')+
  theme_minimal()
```

Elle présente une forme très proche de celle d’une loi normale.

## Analyse *Diff in Diff* multipériodes

Maintenant que nous connaissons mieux la structure de nos données, on a des cross-sections répétées (pas un panel), nous pouvons procéder à l'estimation de notre *Diff in Diff*. Pour cela, nous utiliserons les TWFE (*two ways fixed effects*). Pour les tests sur le coefficient d'intérêt, dans la mesure où le recueil des données se fait par hôpitaux (et donc qu'il doit y avoir plus de variabilité entre les différents hôpitaux que sur les observations par hôpitaux), on utilise des erreurs standards clusterisées sur la base des hôpitaux. Le modèle estimé est le suivant:

$$
 satis_{i,t,s}=\gamma_i+\gamma_t+D_{s,t}+\epsilon_{i,t,s}
$$

où *i* correspond à un hôpital, *t* à un mois et *s* un individu. *D* indique si l'individu a été traité à la date *t* (ici s'il est passé par un hôpital qui avait mis en place la nouvelle procédure le mois où il a été soigné...).

On a ainsi:

```{r}

reg_2<-lm(satis~procedure+factor(hospital)+factor(month),
          data=dat2)
coeftest(reg_2,vcov.=vcovCL(reg_2,cluster=dat2$hospital))[2,] %>%
     round(digits = 7)
```

Le test confirme l'effet positif de l'automatisation de la procédure d'admission. Cette automatisation permet en moyenne d'augmenter la note de satisfaction en moyenne de 0,85 points. Autrement-dit, si les hôpitaux traités (automatisés) ne l'avez pas été, la satisfaction aurait été 0,85 points plus bas.

Le même résultat peut être obtenu à partir d'une spécification classique en *2x2 Diff in Diff*. Pour cela, il est nécessaire de commencer par réaliser quelque manipulations de données. Générons les variables Traite et post.

```{r}

dat2_<-dat2 %>% 
  group_by(hospital) %>% 
  mutate(Traite=ifelse(sum(procedure)==0,"Controles","Traités"),
         post=month>=4)
```

Maintenant que l’on a les données pro format, procédons à la régression et sortons uniquement la ligne associée au coefficient *Diff in Diff*.

```{r}

reg_<-lm(satis~Traite+post+Traite*post,data=dat2_)
coeftest(reg_,vcov.=vcovCL(reg_,cluster=dat2$hospital))[4,] %>%
     round(digits = 7)
```

La spécification en *TWFE* ne permet pas de reconstituer la matrice des moyennes contrairement à celle en *2x2 Diff in Diff* que nous venons de mettre en oeuvre. Établissons-la à partir de ses coefficients.

```{r}

cont_av<-coef(reg_)[1] %>% sum()
cont_ap<-coef(reg_)[c(1,3)] %>% sum()
trait_av<-coef(reg_)[c(1,2)] %>% sum()
trait_ap<-coef(reg_) %>% sum()
mat<-matrix(c(cont_av,cont_ap,trait_av,trait_ap),ncol=2)
colnames(mat)<-c('Controle','Traite')
rownames(mat)<-c('avant','aprés')
rm(cont_av,cont_ap,trait_av,trait_ap)
mat
```

Vérifions que l’ensemble est juste en recalculons notre double différence.

```{r}

(mat[2,2]-mat[1,2])-(mat[2,1]-mat[1,1])
```

Présentons notre résultat sur la forme d’un graphe. Pour cela, passons notre matrice de moyen en data frame et donnons lui une forme adéquate.

```{r}

bas_g<-data.frame(traite=c("Controle","Controle","Traite","Traite"),
                  post=c("avant avril","avril et aprés avril",
                         "avant avril","avril et aprés avril"),
                  satis=c(mat[1,1],mat[2,1],
                        mat[1,2],mat[2,2]))
did<-coef(reg_)[4]
rm(mat)
bas_g
```

Maintenant que nous avons notre data frame, réalisons le graphe.

```{r}

ggplot(bas_g, aes(x = post, 
                  y = satis, 
                  color = traite)) + 
  geom_point() +
  geom_line(aes(group = traite)) +
  labs(title="Effet de la mise en place de l'automatisation des admissions", 
       y="Note moyenne de satisfaction",
       color="")+
  annotate(geom = "segment", x = "avant avril",
           xend = "avril et aprés avril",
           y = bas_g$satis[3],
           yend = bas_g$satis[4] - did,
           linetype = "dashed", color = "grey50") +
  annotate(geom = "segment", x = "avril et aprés avril",
           xend = "avril et aprés avril",
           y = bas_g$satis[4] , 
           yend = bas_g$satis[4] - did,
           linetype = "dotted", color = "blue") +
  annotate(geom = "label", x = "avril et aprés avril",
           y = bas_g$satis[4] - (did / 2), 
           label = "effet du programme", size = 3)+
  theme_bw()+
  theme(
    plot.title = element_text(hjust=0.5),
    axis.title.x = element_blank(),
    legend.position = "top"
  )
rm(bas_g,did)
```

## **Tests complémentaires**

### **Analyses graphiques de la *parallel trend hypothesis***

Examinons l’hypothèse de *parallel trend*. Commençons par une rapide analyse graphique. Reprenons celle développée dans le post précédant. Calculons donc les moyennes de l’*outcome* sur les différents mois respectivement sur le groupe des traités et des non traités (le groupe de contrôle). Créons une fonction pour faciliter les réplications qui suivront. Celle-ci doit permettre de générer un tableau présentant pour chaque mois la satisfaction moyenne sur le groupes de traités et le groupe de contrôle, ainsi que le graphe associée.

```{r}

parallel_plot<-function(var1,trait,time,data,table=TRUE){
    par_1<-data %>% 
          group_by({{trait}},{{time}}) %>% 
          summarise(moy_=mean({{var1}}),.groups = "keep") %>% 
          cbind(trait=c(rep(FALSE,7),rep(TRUE,7)))
    colnames(par_1)<- c("status","month","moy_","trait")
    if(table==TRUE){
    par_1
    }else{
    ggplot(data=par_1,aes(x=month,y=moy_,
                          colour=trait,
                          shape=trait,
                          alpha=trait))+
           geom_point()+
           geom_line()+
           geom_vline(xintercept = 3,
                      linewidth=0.1,linetype="dashed")+
           geom_text(aes(label="Automatisée",
                x=6,
                y=4.25))+
           labs(title = "Satisfaction à l'admission dans les hôpitaux",
                x="mois")+
           scale_x_continuous(breaks=1:7,
                              labels=c("Janvier","Février","Mars","Avril",
                                       "Mai","Juin","Juillet"))+
           scale_y_continuous(breaks = seq(3.2,4.4,0.2))+
           scale_shape_manual(values=c(1, 16))+
           scale_colour_manual(values=c("Black","Black"))+
           scale_alpha_manual(values=c(0.5,1))+
           theme_minimal()+
           theme(
                 plot.title = element_text(hjust=0.5,face="bold"),
                 axis.title.y = element_blank(),
                 axis.title.x = element_blank(),
                 axis.line = element_line(color="black",linewidth=0.1),
                 axis.ticks = element_line(color="black",linewidth=0.1),
                 panel.grid = element_blank(),
                 legend.position="none")}
}
```

Appliquons notre nouvelle fonction pour obtenir le tableau des moyennes.

```{r}

parallel_plot(satis,Traite,month,dat2_)
```

Générons le graphe pour visualiser plus nettement l’hypothèse de *paralell trend* pré traitement.

```{r}

parallel_plot(satis,Traite,month,dat2_,table=FALSE)
```

Le graphe obtenu correspond au premier généré par la fonction **estat trendplots** de Stata. Il s’agit d’une commande post estimation. A sa lecture, on peut dire qu’à première vue que la *parallel trend* pré traitement semble tenir.

Mais allons plus loin. Essayons d’établir le second graphe. Celui-ci est obtenue en commençant par unifier le départ des deux séries puis en les prolongeant à partir d’un *trend* linéaire. Si la *parallel trend* est respectée les deux séries devrait se superposer sur le période pré traitement.

Établissons donc le point de départ en faisant la moyenne des observations sur la première période d’observation.

```{r}

m1<-mean(dat2_$satis[which(dat2_$month==1)])
m1
```

Une fois celui-ci obtenu, calculons les clés d’ajustement à pratiquer sur les deux séries (Contrôles et Traités) pour leur donner la même origine.

```{r}

aj_c<-m1-mean(dat2_$satis[which(dat2_$month==1&dat2_$Traite=="Controles")])
aj_t<-m1-mean(dat2_$satis[which(dat2_$month==1&dat2_$Traite=="Traités")])
c(aj_c,aj_t)
```

Appliquons-les à nos données.

```{r}

dat2_1<-dat2_ %>% 
  mutate(satis_=ifelse(Traite=="Controles",satis+aj_c,satis+aj_t))
rm(aj_c,aj_t)
```

On peut vérifier que l’ajustement a été correctement effectué en calculant la moyen sur le premier mois de notre satisfaction ajustée.

```{r}

mean(dat2_1$satis_[which(dat2_1$month==1)])
```

L’ajustement apparaît être correcte. Etablisons notre second graphe.

```{r}

parallel_plot(satis_,Traite,month,dat2_1,table=FALSE)
```

### **Tests statistiques de la *parallel trend hypothesis***

L’analyse graphique peut être appuyée par un complément statistique. Le focal est toujours porté sur la période pré traitement. La *parallel trend* post traitement, celle qui dans l’absolu, nous intéresse n’est pas testable. Aussi, en nous reportant à la période pré traitement, nous faisant l’hypothèse qu’elle tiendrait post traitement en l’absence de traitement…

Dans les post précédant, pour tester la *parallel trend hypothesis*, nous avons estimé sur la période pré traitement le modèle linéaire suivant :

$$satis=month+month×traité$$

L’outcome est régressé sur une variable marquant la progression du temps et son interaction avec la binaire marquant l’appartenance au groupe des traités.

L’idée est que, si le coefficient associé à la variable d’intéraction est statistiquement différent de 0, on doit rejeter la *parallel trend* dans la mesure où cela montre que le *trend* de l’*outcome* sur la groupe des traités et différents de celui sur le groupe de contrôle. Appliquons la procédure à nos données.

```{r}

reg_p1<-lm(satis~month+month*Traite, 
           data=filter(dat2_,month<4))
coeftest(reg_p1)[4,]
rm(reg_p1)
```

Ici, on ne peut pas rejeté H0, autrement-dit les *trend* sur le groupe des traités et le groupe de contrôle semblent être les mêmes ce qui va dans le sens de la *parallel trend*.

Stata propose un test construit sur le même principe, mais en mobilisant une spécification étendue. La spécification retenue prend pour point de départ celle de la régression en *Diff-in-Diff* pour lui ajouter deux variables proposant une triple interaction la première entre une variable marquant la période pré, l’appartenance au groupe de traité et la période, et la seconde entre une variable marquant la période post et les mêmes variables.

On a ainsi pour une *Diff-in-Diff* estimé en *TWFE* :

$$
satis_{i,t,s}=\gamma_i+\gamma_t+D_{s,t}+\zeta_1.pre.traité.month+\zeta_2.post.traité.month+\epsilon_{i,t,s}
$$

Le test porte alors sur $\zeta_1$. Si ce coefficient est statistiquement différent de zéro, alors il y a une différence de *trend* entre les traités et le groupe de contrôle sur la période pré traitement. Et donc la *parallel trend* ne tiendrait pas. Le test pratiqué est alors un test de *Wald* qui établi sa statistique comme le carré du *t stat* ordinaire. Cette statistique, sous H0 ($\zeta_1=0$), suit une loi de *Fisher* à 1 et n-1 degré de liberté (n étant le nombre d’individu utilisé pour les effets fixes ici le nombre d’hôpitaux). Répliquons le test.

Commençons par préparer les données avant de procéder à l’estimation du modèle. Marquons les périodes pré et post traitement, établissons pour chaque hôpital s’il est traité ou non, enfin calculons les interactions triples.

```{r}

dat2p<-dat2 %>% 
  mutate(pre=ifelse(month<4,1,0),
         post=ifelse(month>3,1,0)) %>% 
  group_by(hospital) %>%
  mutate(trait=ifelse(sum(procedure)==0,0,1)) %>% 
  ungroup() %>% 
  mutate(avant=pre*trait*month,
         apres=post*trait*month)
```

Ceci fait, on peut procéder à la régression, sortir le t stat du coefficient, l’élevé au carré et définir la *p-value* via la loi de *Fisher* a 1 et n-1 degrés de liberté. Ici, n correspond au nombre d’hôpitaux (46).

```{r}

reg_2p<-lm(satis~procedure+avant+apres+factor(hospital)+factor(month),
          data=dat2p)
Fish<-coeftest(reg_2p,vcov.=vcovCL(reg_2p,cluster=dat2p$hospital))[3,3]^2 %>%
     round(digits = 8)
prob<-pf(Fish,1,45,lower.tail=FALSE)
c(F=Fish,pv=prob) %>% round(digits=4)
rm(reg_2p,Fish,prob,dat2p)
```

Comme précédemment on ne peut pas rejeter H0, autrement-dit on ne peut pas rejeté l’hypothèse que $\zeta_1$ soit nulle et donc qu’il n’y ait pas de différence de *trend* entre les futures traités et le groupe de contrôle. L’hypothèse de *parallel trend* pré traitement ne peut donc pas pas être rejetée.

Cela va dans le même sens que l’analyse graphique et que notre test précédent.

### **Analyse graphique de la temporalité du traitement**

En plus de la *parallel trend* (ou comme autre test de cette dernière), on peut s’interroger sur la temporalité des effets du traitement. Est-ce que la date retenue est bien celle à partir de laquelle celui-ci produit des effets? Est-ce qu’il n’y a pas d’anticipation ou de retard ce qui pourrait remettre en cause (au moins en partie) le cadre méthodologique (la *parallel trend* serait en partie remise en cause)? Pour le voir, on peut présenter le graphe de l’effet du traitement dans le temps (comme nous l’avons fait dans le post précédent). Autrement-dit, nous procédons à l’étude des *dynamic treatement effects*.

Il s’agit d’estimer dans un seul modèle, pour une série de dates, l’effet du traitement sur les traités (même s’ils n’ont pas encore été traité) via une spécification de type *2x2 Diff in Diff* . Cela se concrétise par une série d’interactions entre les différentes dates retenues et la variable binaire marquant le fait d’appartenir au groupe des traités. Les dates choisies (généralement retenues) correspondent aux périodes avant l’évènement à l’exception de celle qui le précédent immédiatement (qui sera notre référence) et de l’ensemble de celles après l'évènement.

On a donc ici à estimer le modèle suivant:

$$
satis_{it}=\gamma_i+\gamma_t+\beta_1.T_{−2}.Traité+\beta_2.T_{−1}.Traité+\beta_3.T_1.Traité+\beta_4.T_2.Traité+\beta_5.T_3.Traité+\beta_6.T_4.Traité+\epsilon_{it}
$$

où $T_{−1}$ correspond à janvier, $T_{−2}$ à février, $T_1$ à avril, $T_2$ à mai, etc…

Le traitement est attribué en avril, le mois 4 sur les 7 disponibles. Si on fixe la référence au mois 3, on a 2 *leads* (dans la mesure où ils correspondraient à des anticipations du traitement) et 4 *lags* (dans la mesure où ils correspondraient des effets retardés du traitement).

Pour mettre en oeuvre l’estimation, commençons par centrer nos dates autour de l’évènement en reprenant la base nous ayant permis d’estimer la *2x2 diff in diff* . Celle-ci comprend la variable Traite qui indique si l’observation est issue d’un hôpital qui adoptera ou a adopté le nouveau système. Établissons la variable comme un facteur pour permettre les interactions date par date.

```{r}

dat3<-dat2_ %>% 
  mutate(m_cent3=month-3,
         m_cent3f=relevel(factor(m_cent3),ref="0"))

head(dat3)
```

Ceci fait il ne nous reste plus qu’à établir la régression. Ici, compte tenu du grand nombre de coefficients qui seront calculés (58), nous utiliserons la fonction **feols()** du package *fixest* pour l’estimation. Elle nous permet d’obtenir uniquement la série de coefficient qui nous intéresse. Présentons-les ainsi que les tests associés (toujours avec le *clustering* sur hospital).

```{r message=FALSE}

reg_dyn <- feols(satis ~ m_cent3f*Traite | 
            hospital + month,
            data = dat3)

coeftest(reg_dyn,vcov.=vcovCL(reg_dyn,cluster=dat3$hospital))%>%
     round(digits = 7)
```

On constate que dans leur ensemble les coefficient des *leads* ne sont pas statistiquement significatifs contrairement à ceux de l’ensemble des *lags*. Cela confirme l’absence d’anticipation du traitement. Produisons le graphe permettant de mettre en évidence ce résultat. Celui-ci ce base sur la présentation des intervalles de confiance à 95% des coefficients des différents *leads* et *lags*. Ceux-ci peuvent simplement être obtenu à partir de la fonction **coefci()** du package *lmtest*.

```{r}

coefci(reg_dyn,vcov.=vcovCL(reg_dyn,cluster=dat3$hospital),level=0.95)
```

Pour assembler le graphe, nous avons plusieurs possibilités (comme dans le post précédent). On peut par exemple utiliser la fonction **coefplot()** du package *fixest* ou **ggcoef()** du package *GGally*. Nous optons pour la second solution qui, comme le nom l’indique, utilise la syntaxe de ggplot.

```{r message=FALSE,warning=FALSE}
GGally::ggcoef(reg_dyn,
               errorbar_height = 0.15,
               errorbar_size = 1,
               vline_linetype = "dashed",
               vline_color = "black",
               vline_size = 0.2)+
  annotate(geom="point",x=0,y=2.5)+
    labs(title="Effet dynamique du traitement",
         subtitle = "intervalle de confiance à 95%",
         x="Estimation DiD ",
         y="Mois")+
    scale_y_discrete(labels=c("janvier","fevrier","avril",
                              "mai","juin","juillet"))+
    scale_x_continuous(breaks=seq(0,1,0.2))+
    coord_flip()+  
  theme_minimal()+
  theme(
    plot.title = element_text(hjust = 0.5,face="bold"),
    plot.subtitle = element_text(hjust = 0.5,face="italic"),
    axis.line = element_line(color="black",
                               linewidth=0.15),
    axis.ticks = element_line(color="black",
                               linewidth=0.1),
    panel.grid.minor = element_blank()
  )
```

### Test statistique de la temporalité du traitement

En complément avec l’analyse graphique, on peut pratiquer un test de causalité de type test de Granger pour vérifier si les effets du traitement sont observés avant sa mise en oeuvre (officielle, la date d’évènement). Sous Stata, il est pratiqué en post estimation via la commande **estat granger**. Répliquons la.

Le test part de la même modélisation que celle que nous avons mobilisée pour générer le graphe du *dynamic treatement effects* à la différence prés que seul les *leads* sont considérés. Il s’agira alors de tester l’hypothèse jointe (H0) que les coefficients associés sont tous égaux à 0. Cela est réalisé à partir d’un test de Wald dont la statistique suit une loi de Fisher égale au nombre de *leads* et au nombre de *cluster* moins 1.

Avant de procéder au test, créons une variable indiquant les *leads*, la référence et les *lags*.

```{r}

dat3<-dat3 %>% 
  mutate(leads_=ifelse(m_cent3%in%c(-2,-1,0),m_cent3f,"lags"),
         leads_f=relevel(factor(leads_,labels = c("0","-2","-1","lags")),
                         ref="0"))

head(dat3)[,c(3,8:11)]
```

Une fois les données prêtes, il ne reste plus qu’à réaliser la régression. Observons-en les résultats.

```{r message=FALSE}

reg_dyn_ <- feols(satis ~ leads_f*Traite | 
            hospital + month,
            data = dat3)

coeftest(reg_dyn_,vcov.=vcovCL(reg_dyn_,cluster=dat3$hospital))%>%
     round(digits = 7)
```

Les deux coefficients associés aux *leads* ne sont pas statistiquement différents de zéro. Il ne semble pas y avoir d’anticiaption des effets du traitement. Néanmoins, pour aller au bout de la démarche, pratiquons le test d’hypothèse jointe sur ces coefficients (H0 les deux coefficients sont égale à 0). Pour cela, utilisons la fonction **linearHypothesis()** qui est issue du package *car*. Indiquons les hypothèses à tester et la nature de la statistique retenue (ici F pour Fisher).

```{r}

linearHypothesis(reg_dyn_,c("leads_f-2:TraiteTraités = 0",
                            "leads_f-1:TraiteTraités = 0"),
                 test="F",
                 vcov.=vcovCL(reg_dyn_,cluster=dat3$hospital),
                 white.adjust="hc1")
rm(reg_dyn,reg_dyn_,dat3)
```

Le test confirme que l’on ne peut par raisonnablement rejeter H0. Cela va dans le sens d’une absence d’effets du traitement avant la date désignée comme étant celle de sa mise en place. L’hypothèse de non anticipation semble tenir.

Pour résumer, la mise en place de l'automatisation de la procédure d’enregistrement des patients apparaît bien améliorer la satisfaction des patients. La méthode utilisée pour le mettre en évidence l’analyse en *Diff in Diff* (double différence) le confirme. Par ailleurs, les hypothèses sur lesquelles reposent cette méthode pour être mise en oeuvre *parallel trend* et non anticipation apparaissent également vérifiées.
